<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="jmVkZTbVPelojD8M5GYWjhn_HjTehrAB4WG1TYife8A">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpeg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpeg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpeg?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="之前的内容我们讲的是Flutter的基本布局控件使用方式，包括单元素布局与多元素布局。为什么会有这两种区分呢？还有一些控件根本没有布局方式，比如RichText，那它是怎么展示的？ 这一节我们就来深入看下Flutter的Widget是怎么构建、布局、渲染的，它们之间又靠什么联系在一起。">
<meta name="keywords" content="Flutter,dart,性能">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter渲染原理与性能优化">
<meta property="og:url" content="http://xinbaos.github.io/Flutter渲染原理与性能优化/index.html">
<meta property="og:site_name" content="xinbao的书屋">
<meta property="og:description" content="之前的内容我们讲的是Flutter的基本布局控件使用方式，包括单元素布局与多元素布局。为什么会有这两种区分呢？还有一些控件根本没有布局方式，比如RichText，那它是怎么展示的？ 这一节我们就来深入看下Flutter的Widget是怎么构建、布局、渲染的，它们之间又靠什么联系在一起。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xinbaos.github.io/flutter/Flutter%20Demo效果.jpg">
<meta property="og:image" content="http://xinbaos.github.io/flutter/Demo的Widget树.png">
<meta property="og:image" content="http://xinbaos.github.io/flutter/widget优化示意图1.png">
<meta property="og:image" content="http://xinbaos.github.io/flutter/state生命周期.png">
<meta property="og:image" content="http://xinbaos.github.io/flutter/element生命周期.png">
<meta property="og:updated_time" content="2019-05-20T07:29:41.867Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flutter渲染原理与性能优化">
<meta name="twitter:description" content="之前的内容我们讲的是Flutter的基本布局控件使用方式，包括单元素布局与多元素布局。为什么会有这两种区分呢？还有一些控件根本没有布局方式，比如RichText，那它是怎么展示的？ 这一节我们就来深入看下Flutter的Widget是怎么构建、布局、渲染的，它们之间又靠什么联系在一起。">
<meta name="twitter:image" content="http://xinbaos.github.io/flutter/Flutter%20Demo效果.jpg">






  <link rel="canonical" href="http://xinbaos.github.io/Flutter渲染原理与性能优化/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Flutter渲染原理与性能优化 | xinbao的书屋</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xinbao的书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">突破生命的层次，创造新的自我，新的事物，新的生命</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xinbaos.github.io/Flutter渲染原理与性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oldsun">
      <meta itemprop="description" content="修身，齐家，治国，平天下">
      <meta itemprop="image" content="/images/header.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xinbao的书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flutter渲染原理与性能优化

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-20 20:49:07" itemprop="dateCreated datePublished" datetime="2019-03-20T20:49:07+08:00">2019-03-20</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">91k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:23</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前的内容我们讲的是Flutter的基本布局控件使用方式，包括单元素布局与多元素布局。为什么会有这两种区分呢？还有一些控件根本没有布局方式，比如RichText，那它是怎么展示的？</p>
<p>这一节我们就来深入看下Flutter的Widget是怎么构建、布局、渲染的，它们之间又靠什么联系在一起。</p>
<a id="more"></a>
<p>首先我们从官方示例开始看起。</p>
<h2 id="flutter示例说明">Flutter示例说明</h2>
<p>使用Android Studio创建Flutter工程，会创建一个默认的界面，我们可以从这个界面分析出一点内容。<br><br>
<code>main.dart</code> 内容如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        <span class="comment">// This is the theme of your application.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Try running your application with "flutter run". You'll see the</span></span><br><span class="line">        <span class="comment">// application has a blue toolbar. Then, without quitting the app, try</span></span><br><span class="line">        <span class="comment">// changing the primarySwatch below to Colors.green and then invoke</span></span><br><span class="line">        <span class="comment">// "hot reload" (press "r" in the console where you ran "flutter run",</span></span><br><span class="line">        <span class="comment">// or simply save your changes to "hot reload" in a Flutter IDE).</span></span><br><span class="line">        <span class="comment">// Notice that the counter didn't reset back to zero; the application</span></span><br><span class="line">        <span class="comment">// is not restarted.</span></span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This widget is the home page of your application. It is stateful, meaning</span></span><br><span class="line">  <span class="comment">// that it has a State object (defined below) that contains fields that affect</span></span><br><span class="line">  <span class="comment">// how it looks.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This class is the configuration for the state. It holds the values (in this</span></span><br><span class="line">  <span class="comment">// case the title) provided by the parent (in this case the App widget) and</span></span><br><span class="line">  <span class="comment">// used by the build method of the State. Fields in a Widget subclass are</span></span><br><span class="line">  <span class="comment">// always marked "final".</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// This call to setState tells the Flutter framework that something has</span></span><br><span class="line">      <span class="comment">// changed in this State, which causes it to rerun the build method below</span></span><br><span class="line">      <span class="comment">// so that the display can reflect the updated values. If we changed</span></span><br><span class="line">      <span class="comment">// _counter without calling setState(), then the build method would not be</span></span><br><span class="line">      <span class="comment">// called again, and so nothing would appear to happen.</span></span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// This method is rerun every time setState is called, for instance as done</span></span><br><span class="line">    <span class="comment">// by the _incrementCounter method above.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The Flutter framework has been optimized to make rerunning build methods</span></span><br><span class="line">    <span class="comment">// fast, so that you can just rebuild anything that needs updating rather</span></span><br><span class="line">    <span class="comment">// than having to individually change instances of widgets.</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        <span class="comment">// Here we take the value from the MyHomePage object that was created by</span></span><br><span class="line">        <span class="comment">// the App.build method, and use it to set our appbar title.</span></span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        <span class="comment">// Center is a layout widget. It takes a single child and positions it</span></span><br><span class="line">        <span class="comment">// in the middle of the parent.</span></span><br><span class="line">        child: Column(</span><br><span class="line">          <span class="comment">// Column is also layout widget. It takes a list of children and</span></span><br><span class="line">          <span class="comment">// arranges them vertically. By default, it sizes itself to fit its</span></span><br><span class="line">          <span class="comment">// children horizontally, and tries to be as tall as its parent.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Invoke "debug painting" (press "p" in the console, choose the</span></span><br><span class="line">          <span class="comment">// "Toggle Debug Paint" action from the Flutter Inspector in Android</span></span><br><span class="line">          <span class="comment">// Studio, or the "Toggle Debug Paint" command in Visual Studio Code)</span></span><br><span class="line">          <span class="comment">// to see the wireframe for each widget.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Column has various properties to control how it sizes itself and</span></span><br><span class="line">          <span class="comment">// how it positions its children. Here we use mainAxisAlignment to</span></span><br><span class="line">          <span class="comment">// center the children vertically; the main axis here is the vertical</span></span><br><span class="line">          <span class="comment">// axis because Columns are vertical (the cross axis would be</span></span><br><span class="line">          <span class="comment">// horizontal).</span></span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">'You have pushed the button this many times:'</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">'<span class="subst">$_counter</span>'</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前写了很多常用widget的使用方法，但是还没有系统地对展示过程进行说明，这里对Demo中的每一行作用，进行详细说明：</p>
<ul>
<li>
<p><code>import 'package:flutter/material.dart';</code>这是dart语言的用法，这里导入的是MaterialDesign风格的包，里面有各种MaterialDesign风格控件以及常用控件。我们常用的MaterialApp、Scaffold、RaisedButton、Card等，都属于MaterialDesign风格的控件。</p>
</li>
<li>
<p><code>void main() =&gt; runApp(MyApp());</code> 这个是主方法入口，<code>main</code>方法为程序调用方法，<code>runApp</code>方法将一个Widget加到根节点中，添加方式稍后再原理解析中详细说明。<code>MyApp()</code>创建了一个Widget对象，下面的代码是MyApp类的声明。</p>
</li>
<li>
<p><code>MyApp</code>类声明中，说明了这是一个StatelessWidget的子类。也就是说，这个类应该是无状态的，里面的字段应该是不可变更的，为final类型。如果想要更新这个Widget的展示效果，只能重新创建一个新的对象来实现而不能复用原来对象。</p>
</li>
<li>
<p>MyApp的<code>build</code>方法返回了需要展示的Widget内容，这里返回的Widget和MyApp本身没有关系，只是他们的Element有关系，这一点要弄清楚，我之前也是在这一项卡了很久才理解。如果真的要想象这两个有关系，可以认为是父子关系。在这里返回的Widget是MaterialApp，这是一个典型的MaterialDesign应用，里面指定了theme，而在home中设置的是真正的界面widget.另外MaterialApp中也支持路由设置。</p>
</li>
<li>
<p><code>MyHomePage</code>类声明中，说明了这是一个StatefulWidget的子类，它与StatelessWidget的区别在于它无需重建类即可变更界面内容，变更方式通过State来实现。</p>
</li>
<li>
<p><code>_MyHomePageState</code>中存储了<code>MyHomePage</code>的状态信息，在State中进行变更，界面会随之变动。同样通过build方法提供界面展示效果，里面返回的是一个<code>Scaffold</code>类型Widget，这是最常用的MaterialDesign风格设计框架，提供了各种展示效果。在Demo中分别提供了AppBar、界面主体以及一个浮动按钮。在<code>_MyHomePageState</code>中还设置了一个方法，点击按钮时，更新界面展示内容。</p>
</li>
</ul>
<p>下面是一个这个界面的效果：</p>
<img src="../flutter/Flutter Demo效果.jpg" width="55%">
<h2 id="widge类型说明">Widge类型说明</h2>
<p>在Demo中使用到了几种Widget？一一列出来：MyApp、MaterialApp、MyHomePage、Scaffold、AppBar、Text、Center、Column、FloatingActionButton、Icon.<br></p>
<p>这么多组件中，我们自己定义的只有两个：MyApp、MyHomePage，而这两个控件的父类，分别是：StatelessWidget、StatefulWidget，这两种也是Flutter推荐使用的两个父控件类型。<br></p>
<p>按照官方的设计原则，StatelessWidget、StatefulWidget这两种组合Widget基本上可以满足需要的所有情况，不过这不意味着我们不能自定义其它Widget.</p>
<p>下面列出几种经常遇到的基础Widget：</p>
<ul>
<li>
<p>StatelessWidget 组合型Widget，widget实例创建后，不可更改。比如：Container、RaisedButton等，如果有变动，需要重新创建实例。</p>
</li>
<li>
<p>StatefulWidget 组合型Widget，widget实例携带一个state实例，state实例内容可变更。这种Widget一般用于界面绘制的桥梁。但是如果滥用也会产生性能问题，本文后面会根据源码给出性能优化建议。</p>
</li>
<li>
<p>RenderObjectWidget 渲染型Widget，这种一般是基础widget，可以将该widget内容渲染出来。</p>
</li>
<li>
<p>SingleChildRenderObjectWidget 渲染型Widget，这种是RenderObjectWidget的一个子类，特点是该Widget只有一个子控件，比如之前介绍过的Padding、Align等。</p>
</li>
<li>
<p>MultiChildRenderObjectWidget 渲染型Widget，这种同样是RenderObjectWidget的一个子类，特点是该widget可以有超过一个的子控件，比如之前介绍过的Flex等。</p>
</li>
<li>
<p>LeafRenderObjectWidget 渲染型Widget，这种同样是RenderObjectWidget的一个子类，特点是该widget不会有子控件，只是由其本身进行渲染，比如RichText、RawImage等。</p>
</li>
<li>
<p>ProxyWidget 代理型Widget，这种widget用来进行数据在widget之间传递，比如常用的InheritedWidget，一般的状态管理框架也是基于这个原理实现的。</p>
</li>
</ul>
<p>我们的Demo，乃至于各种复杂的界面，主要也是这几种Widget组成的。</p>
<h2 id="界面构建过程">界面构建过程</h2>
<p>上面说了几种基础Widget类型，如果将Demo中涉及到的Widget整理成一个树（实际上widget不算是一个真正的树，至少不是一个静态树，真正的树是Element和RenderObject），可以看到如下结构：<br>
<img src="../flutter/Demo的Widget树.png" width="50%"></p>
<p>在树形结构中可以看到Widget的互相依赖过程，但是这个Widget树是怎样变成我们可见的界面的？中间经过了哪些转换过程？我们先说一下两个开发时没有涉及到的东西：<code>Element</code>和<code>RenderObject</code></p>
<ul>
<li>
<p>Element 这个是真正的节点，用来关联Widget与渲染对象。每一个Widget都对应着一个Element，但是Widget实例会经常变动，但是渲染树不能经常改变，因此Element会尽可能改变而不是重新创建。</p>
</li>
<li>
<p>RenderObject 是一个渲染节点数，这里面的每一个节点都会在界面上绘制出来。RenderObject与Element或者Widget不是一一对应的，只有RenderObjectWidget以及它的子类才会存在RenderObject</p>
</li>
</ul>
<h3 id="widget-element和renderobject三者关系">Widget、Element和RenderObject三者关系</h3>
<p>上面简单介绍了Element、RenderObject，但是感觉还是不清楚，下面我们通过Flutter源码进行说明：</p>
<p>查看<code>Widget</code>类的代码，里面有这样一项：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> createElement();</span><br></pre></td></tr></table></figure>
<p>这个就是Widget对应的Element，在不同的Widget中，会创建不同的Element，比如StatelessElement、StatefulElement、RenderObjectElement、SingleChildRenderObjectElement、MultiChildRenderObjectElement、LeafRenderObjectElement、ProxyElement等。因为是一一对应，同样在Element中也会持有Widget的对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget <span class="keyword">get</span> widget =&gt; _widget;</span><br><span class="line">  Widget _widget;</span><br></pre></td></tr></table></figure>
<p>而RenderObject则针对的是可渲染Widget，也就是RenderObjectWidget，部分代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RenderObject createRenderObject(BuildContext context);</span><br></pre></td></tr></table></figure>
<p>也就是说会在RenderObjectWidget的子类中创建RenderObject，但是实际上这样做只是为了方便开发人员使用，真正情况还是在Element中持有RenderObject对象，如下面代码所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RenderObject <span class="keyword">get</span> renderObject =&gt; _renderObject;</span><br><span class="line">  RenderObject _renderObject;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>所以三者的情况就是Widget用于开发人员设计控件，RenderObject用于界面渲染，Element连接两者展示。</p>
<h3 id="flutter与android界面开发对比">Flutter与Android界面开发对比</h3>
<p>Android界面开发是命令式的，如果需要变更某一个View，需要获取该View的句柄，然后对view进行参数变更。这样的实现方式有很强的针对性，同时绘制过程中也会自动判断，可以精准的对某一个View进行绘制。但是这种方式有一些缺点，如果变动的view比较多时，就需要为每一项单独设置，而且需要开发人员自己控制的话，较为复杂的界面逻辑需要很强的处理能力。</p>
<p>Flutter界面开发是声明式的，每次只要定义好数据项，同时声明这些数据项与Widget的绑定关系。真正使用时，只需要变更数据内容，然后重建Widget实例就可以了。这种方式的优势就是简单粗暴，并更数据集后，绑定的相关界面项会自动调整。但是所有相关Widget都换了一遍，如果渲染内容的实例（也就是RenderObject）也都重新变更一遍，那对于界面效果来说，是一个非常严重的打击。</p>
<p>但是实际上，Flutter的渲染效率很高，Widget虽然重建，但是Element以及RenderObject不一定会进行重建，具体的渲染过程，我们可以跟踪源码来看下。</p>
<h3 id="界面创建过程">界面创建过程</h3>
<p>main方法是主入口，里面只调用了runApp方法。可以看下这个方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意里面的<code>attachRootWidget</code>方法，这个方法是将我们提供的Widget添加到RootWidget中，具体代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">      child: rootWidget</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了<code>attachToRenderTree</code>，这个方法将当前渲染内容加入到渲染树中，看相关代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [RenderObjectToWidgetElement&lt;T&gt; element]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element, () &#123;</span><br><span class="line">        element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始情况下，RootElement为空，因此创建新的Element。然后通过<code>BuildOwner.buildScope</code>将Element树以及RenderObject树添加子节点。实际上<code>buildScope</code>这个方法不仅在创建界面时用到，刷新界面时同样用到了，后面刷新界面时详细说明一下。</p>
<p>在创建界面时buildScope方法可以简化为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback callback]) &#123;</span><br><span class="line">    ···</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ···</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看出，实际上只是执行了传入的callback方法。继续根据传入的方法，只是执行了如下语句：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这个是根节点进行mount操作，因为没有父节点，所以parent传为空，查看相应代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _rebuild();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>_rebuild()</code>代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, widget.child, _rootChildSlot);</span><br><span class="line">      <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      <span class="keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">'widgets library'</span>,</span><br><span class="line">        context: <span class="string">'attaching to the render tree'</span></span><br><span class="line">      );</span><br><span class="line">      FlutterError.reportError(details);</span><br><span class="line">      <span class="keyword">final</span> Widget error = ErrorWidget.builder(details);</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, error, _rootChildSlot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>updateChild</code>同样也是界面创建于刷新时的重要处理过程，后面会详细说明，这里只需要认为这里会进行子控件的添加，而且是递归添加处理，分别调用子控件的<code>mount</code>操作。其中<code>widget.child</code>就是我们传入的Widget实例，在Demo中就是<code>MyApp()</code>。</p>
<p>查看<code>Element</code>类的mount方法，这里将RenderObject加入到相应的树中。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123; _debugUpdateRenderObjectOwner(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">    <span class="keyword">assert</span>(_slot == newSlot);</span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>之前我们说过，Element与RenderObject不是一一对应的，所以需要寻找到可用的父RenderObject，再添加新的节点。</p>
<h3 id="界面刷新过程">界面刷新过程</h3>
<p>上面的创建过程很好理解，每个Widget都有一个Element，同时也与RenderObject保持关系。但是这样做很麻烦，为什么不直接创建一个渲染节点呢？就像Android那样做？还要维护三者间的关系。<br><br>
我们之前也写过，Widget是可以随意创建的，但是Element却要尽可能地保持复用，所以刷新时这三者关系还要再好好设计。</p>
<p>界面刷新需要一个切入点(比如Android通过<code>invalidate</code>通知)，在Flutter中，就是通过State的<code>setState</code>方法来进行刷新。</p>
<p>查看setState源码，去掉一些无用代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">	···</span><br><span class="line">    _element.markNeedsBuild();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是调用Element的<code>markNeedsBuild</code>方法，继续查看：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里面将Element标记为dirty，然后调用<code>scheduleBuildFor</code>方法，继续查看：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (element._inDirtyList) &#123;</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      onBuildScheduled();</span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.add(element);</span><br><span class="line">    element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里将该element加入到_dirtyElements中，标记这个节点刷新时需要进行处理。然后执行了<code>onBuildScheduled</code>方法。这个方法进行了什么操作，继续查找源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">buildOwner.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _handleBuildScheduled() &#123;</span><br><span class="line">	···</span><br><span class="line">	ensureVisualUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">        scheduleFrame();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">    _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> scheduleFrame() native <span class="string">'Window_scheduleFrame'</span>;</span><br></pre></td></tr></table></figure>
<p>终于找到了，调用了一个native方法 <code>Window_scheduleFrame</code>，这个方法在Flutter Engine中实现。查看注释内容，会回调<code>onBeginFrame</code>和<code>onDrawFrame</code>这两个方法。继续查找源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onBeginFrame = _handleBeginFrame;</span><br><span class="line"><span class="built_in">window</span>.onDrawFrame = _handleDrawFrame;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>由于相关代码较多，这里简化一下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (renderViewElement != <span class="keyword">null</span>)</span><br><span class="line">        buildOwner.buildScope(renderViewElement);</span><br><span class="line">      <span class="keyword">super</span>.drawFrame();</span><br><span class="line">      buildOwner.finalizeTree();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>又调用到了<code>buildOwner.buildScope</code>方法！</p>
<p>之前创建界面时采用了这个方法，现在刷新时也用到了，详细说明一下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback callback]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    ···</span><br><span class="line">    Timeline.startSync(<span class="string">'Build'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ···</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ···</span><br><span class="line">      	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _dirtyElements[index].rebuild();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">          ···</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting) &#123;</span><br><span class="line">          _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">          _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">          dirtyCount = _dirtyElements.length;</span><br><span class="line">          <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</span><br><span class="line">            <span class="comment">// It is possible for previously dirty but inactive widgets to move right in the list.</span></span><br><span class="line">            <span class="comment">// We therefore have to move the index left in the list to account for this.</span></span><br><span class="line">            <span class="comment">// We don't know how many could have moved. However, we do know that the only possible</span></span><br><span class="line">            <span class="comment">// change to the list is that nodes that were previously to the left of the index have</span></span><br><span class="line">            <span class="comment">// now moved to be to the right of the right-most cleaned node, and we do know that</span></span><br><span class="line">            <span class="comment">// all the clean nodes were to the left of the index. So we move the index left</span></span><br><span class="line">            <span class="comment">// until just after the right-most clean node.</span></span><br><span class="line">            index -= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(element._inDirtyList);</span><br><span class="line">        element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.clear();</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">      ···</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码中可以看到，首先将_dirtyElements进行排序，这是因为节点可能有很多个，如果其中两个节点存在级联关系，父级的Widget build操作必然会调用到子级的Widget build，如果子级又自己build一次，相当于出现了重复操作。因此通过深度排序就会避免这个问题。</p>
<p>排序结束后，对每一个Element进行遍历，执行rebuild操作。需要注意的是，如果在遍历过程中增加了新的节点，那么就需要重新排序。rebuild操作后面详细说明。</p>
<p>所有Element都rebuild后，清空_dirtyElements集合，节点状态恢复正常。</p>
<p>rebuild示意代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    ···</span><br><span class="line">    performRebuild();</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    ···</span><br><span class="line">    Widget built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      built = build();</span><br><span class="line">      debugWidgetBuilderValue(widget, built);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      built = ErrorWidget.builder(_debugReportException(<span class="string">'building <span class="subst">$this</span>'</span>, e, stack));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// We delay marking the element as clean until after calling build() so</span></span><br><span class="line">      <span class="comment">// that attempts to markNeedsBuild() during build() will be ignored.</span></span><br><span class="line">      _dirty = <span class="keyword">false</span>;</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);</span><br><span class="line">      ···</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      built = ErrorWidget.builder(_debugReportException(<span class="string">'building <span class="subst">$this</span>'</span>, e, stack));</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>build</code>方法最终调用的是Widget中对应的build方法。<code>updateChild</code>方法同样也是创建界面时调用的方法，继续跟踪源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是Widget实例变更，但是Element实例不变的核心了，这里分成了四种情况分别处理：</p>
<ul>
<li>如果不存在新的Widget，那么说明这一个节点应该取消掉了，执行<code>deactivateChild</code>方法。</li>
<li>如果子节点的widget和新的widget一致（这里的一致指的是同一个对象，这个也是允许的），直接返回这个子节点。</li>
<li>如果两个widget不是同一个对象，判断类型是否相同，通过<code>canUpdate</code>方法判断，依据是Widget类型一致，同时Key一致。这种情况下，只需要更新子节点就好了。因此这一步就是widget变更，但是element不变更的原因。</li>
<li>其它情况下则认为子节点是新增的，调用<code>inflateWidget</code>进行子节点创建，里面与创建界面相同，执行了mount操作。</li>
</ul>
<p>上面的代码都是ComponentElement的类中处理方式，也就是常用的StatelessWidget与StatefulWidget使用的Element。这个过程比较复杂，按照我个人的见解来说，如果想要不进行变更，父级的Widget是不能改变的，否则无法找到锚点，所以界面刷新都是从StatefulWidget开始的，而不能从StatelessWidget开始。刷新开始后，在rebuild中进行递归处理，以StatefulWidget实例为锚点，一级一级地维护Widget与Element的关系。</p>
<p>如果不是ComponentElement，针对RenderObjectElement，则会调用下面的处理：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>每一种RenderObjectElement都会有自己的<code>updateRenderObject</code>处理方式，类似于Android的View操作，针对每一个View来设置属性，这里不再详细说明。</p>
<p>到这里，<code>buildOwner.buildScope(renderViewElement);</code>方法就已经结束了，还记得不，再贴一下drawFrame代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (renderViewElement != <span class="keyword">null</span>)</span><br><span class="line">        buildOwner.buildScope(renderViewElement);</span><br><span class="line">      <span class="keyword">super</span>.drawFrame();</span><br><span class="line">      buildOwner.finalizeTree();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>剩下执行<code>super.drawFrame();</code>，通过pipelineOwner将RenderObject绘制到界面上，不再详细说说明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后再执行<code>buildOwner.finalizeTree();</code>，这里面将一些设置为deactive的Element进行回收，这部分涉及到了生命周期，下面会详细说明。</p>
<h2 id="界面渲染过程">界面渲染过程</h2>
<p>继续上面的内容，前面说了界面构建的过程，创建好了RenderObject树，那么RenderObject tree怎么进行渲染呢？</p>
<p>继续看<code>drawFrame</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>pipelineOwner.flushLayout()</code>对需要relayout的RenderObject对象重新测量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    profile(() &#123;</span><br><span class="line">      Timeline.startSync(<span class="string">'Layout'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    &#125;);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// TODO(ianh): assert that we're not allowing previously dirty nodes to redirty themselves</span></span><br><span class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">            node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ···</span><br><span class="line">      profile(() &#123;</span><br><span class="line">        Timeline.finishSync();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先将_nodesNeedingLayout集合根据节点深度进行排序，然后重新进行layout。_nodesNeedingLayout集合的内容在每个RenderObject更新时会进行标记的，比如RichText:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> text(TextSpan value) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">switch</span> (_textPainter.text.compareTo(value)) &#123;</span><br><span class="line">      ···</span><br><span class="line">      <span class="keyword">case</span> RenderComparison.layout:</span><br><span class="line">        _textPainter.text = value;</span><br><span class="line">        _overflowShader = <span class="keyword">null</span>;</span><br><span class="line">        markNeedsLayout();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">    ···</span><br><span class="line">    owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">    owner.requestVisualUpdate();</span><br><span class="line">  	···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>查看源码，<code>_layoutWithoutResize</code>方法基本上就是调用<code>performLayout</code>方法，这个方法在每个RenderObject中的实现都不一样，不过约定是进行布局展示后，调用child.layout方法，继续查看这个方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    ···</span><br><span class="line">    RenderObject relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">      relayoutBoundary = parent._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">      ···</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _constraints = constraints;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">      ···</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        performResize();</span><br><span class="line">        <span class="keyword">assert</span>(() &#123; debugAssertDoesMeetConstraints(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">        _debugReportException(<span class="string">'performResize'</span>, e, stack);</span><br><span class="line">      &#125;</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject debugPreviousActiveLayout;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();</span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">      <span class="keyword">assert</span>(() &#123; debugAssertDoesMeetConstraints(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以分析出很多东西：</p>
<p><code>!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject</code> 这四种判断条件设置relayoutBoundary为RenderObject本身，这有什么用？用处可大了。</p>
<p>约束条件是沿着树的深度，从上到下的，但是layout布局是从下到上的，这个很好理解。大部分情况下，父控件的大小除了约束条件外，还依赖于子控件的大小，所以要从下向上分别layout，当然paint正好相反，是从上到下的顺序，这个后面说明。relayoutBoundary指的是布局边界，也就是说，这个renderObject的大小是固定的，不会因为其子节点的大小而变化，这种情况下就可以认为这个RenderObject就是一个锚点，它的子节点有变动，不会影响到父节点的layout。</p>
<p>那上面这四种情况分别是什么呢？首先还是需要先说明下约束条件</p>
<h3 id="约束条件">约束条件</h3>
<p>为了简单说明，这里只说下<code>BoxConstraints</code>，也就是边界约束，而更为复杂的<code>SliverConstraints</code>其它文章中再详细说明。</p>
<p>先看下BoxConstraints的构造方法，里面就已经包括了所有属性：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints(&#123;</span><br><span class="line">    <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity,</span><br><span class="line">    <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>这个很好理解，看字面意思就能明白，分别约束了最大/最小宽度、最大/最小高度，也就是要求渲染后的视图一定要在这个范围内展示。而上面的构造方法则展示了最为宽松的约束条件：最小高度或宽度为0，最大高度或宽度为无穷大。</p>
<p>在实际使用时，一般会将父节点的约束条件传递给子节点，如果子节点有额外的约束条件，则进行比对添加，然后再传给下一级。</p>
<p>约束条件很简单，但是根据这四种条件，会有几种类型：</p>
<ul>
<li>tight 如果最小约束(minWidth，minHeight)和最大约束(maxWidth，maxHeight)是一样的，那么就限定死了这个节点的宽度与高度。</li>
<li>loose 如果最小约束都是0.0</li>
<li>bounded 如果最大约束都不是double.infinity</li>
<li>unbounded 如果最大约束都是double.infinity</li>
<li>expanding 如果最小约束和最大约束都是infinite</li>
</ul>
<p>明确约束的概念后，我们继续分析渲染过程。</p>
<h3 id="继续渲染过程分析">继续渲染过程分析</h3>
<p>之前说到了四种情况，下面分别进行说明：</p>
<ul>
<li>!parentUsesSize parentUsesSize表示父节点是否要依赖子节点的size，如果该值为false，子节点要重新布局的时候并不需要通知父节点</li>
<li>sizedByParent sizedByParent表示当前的节点虽然不是isTight，但是通过其他约束属性，也可以明确的知道size，比如Expanded，并不一定需要明确的size</li>
<li>constraints.isTight 这个上面已经说明了</li>
<li>parent is! RenderObject 这个更明确了，父节点都不能进行渲染，自然不能进行size操作</li>
</ul>
<p>非四种情况下，则调用<code>performResize</code>与<code>performLayout</code>遍历所有子节点，直到layout完成。</p>
<p>按照之drawFrame处理，<code>flushLayout</code>完成后进行<code>flushCompositingBits</code>，这个方法是用来为每个RenderObject设置适当needCompositing值，最终needCompositing将会决定生成多少layer提交给引擎，引擎中叠加绘制每一层layer（skia等经典用法，mix也是类似实现）。查看下面代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(<span class="string">'Compositing bits'</span>); &#125;);</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _updateCompositingBits() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_needsCompositingBitsUpdate)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> oldNeedsCompositing = _needsCompositing;</span><br><span class="line">    _needsCompositing = <span class="keyword">false</span>;</span><br><span class="line">    visitChildren((RenderObject child) &#123;</span><br><span class="line">      child._updateCompositingBits();</span><br><span class="line">      <span class="keyword">if</span> (child.needsCompositing)</span><br><span class="line">        _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary || alwaysNeedsCompositing)</span><br><span class="line">      _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldNeedsCompositing != _needsCompositing)</span><br><span class="line">      markNeedsPaint();</span><br><span class="line">    _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>每一个layer内容会同步变更，可以将一些paint较为复杂的节点单独设置一个layer，或者经常变动的paint设置为单独layer，这样可以减少多次paint导致的性能耗损。</p>
<p>继续查看<code>flushPaint</code>相关代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(<span class="string">'Paint'</span>, arguments: timelineWhitelistArguments); &#125;);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">      <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">      <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(node._layer != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">            PaintingContext.repaintCompositedChild(node);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ···</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ···</span><br><span class="line">      profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>基本格式与前面一样，注意<code>PaintingContext.repaintCompositedChild</code>这个方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">    RenderObject child, &#123;</span><br><span class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">    PaintingContext childContext,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (child._layer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ···</span><br><span class="line">      child._layer = OffsetLayer();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ···</span><br><span class="line">      child._layer.removeAllChildren();</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">    child._paintWithContext(childContext, Offset.zero);</span><br><span class="line">    childContext.stopRecordingIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    ···</span><br><span class="line">    RenderObject debugLastActivePaint;</span><br><span class="line">    ···</span><br><span class="line">    _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      paint(context, offset);</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>isRepaintBoundary为true的RenderObject会创建一个自己的layer，最终调用了<code>RenderObject.paint</code>方法。</p>
<p>Flutter会把所有的layer都加入到ui.SceneBuilder对象中。然后在<code>renderView.compositeFrame()</code>中 ui.SceneBuilder会构建出ui.Scene（场景），交给ui.window.render方法去做最后真实渲染，最终绘制过程在Flutter引擎中实现并展示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> compositeFrame() &#123;</span><br><span class="line">    Timeline.startSync(<span class="string">'Compositing'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class="line">      <span class="keyword">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class="line">      <span class="keyword">if</span> (automaticSystemUiAdjustment)</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      _window.render(scene);</span><br><span class="line">      scene.dispose();</span><br><span class="line">      ···</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止，界面构建过程与渲染过程都已经说明完，那我们跟踪源码的目的是什么呢？至少我们可以做到下面三点：</p>
<ul>
<li>可以对源码进行修改。目前的代码还不是很完善，对于一些特殊的要求，我们可以通过源码修改的方式来完成，而且根据实践，在Android Studio中修改后的源码可以直接参与编译，不需要任何过程。</li>
<li>了解渲染过程，同时也了解了Widget、Element、RenderObject的处理方式以及生命周期，可以自己实现自定义的控件效果。</li>
<li>了解整个渲染过程，出现问题后能够知道瓶颈在哪里，同时增加绘制效率，防止卡顿发生。</li>
</ul>
<h2 id="性能优化">性能优化</h2>
<p>上面主要分析的是ComponentWidget以及相关Element，那就先从这里的优化方向说起。</p>
<p>之前我写过，绘制的锚点在于StatefulWidget，这个Widget的实例是不变的，而State的build方法，会创建出大量新的widget。这些widget对象创建本身就有开销，再加上element的对比判断等等，所以在这方面，我们可以尽可能地提高效率。</p>
<ul>
<li>
<p>StatelessWidget本身是不可变的，我们使用的StatefulWidget类都应该先判断是否值得，如果可以的话，应该使用StatelessWidget进行替代。比如每个界面的框架类，如果是不变的，就应该使用StatelessWidget，只有需要变更项才会使用StatefulWidget。</p>
</li>
<li>
<p>更新的StatefulWidget设计时尽可能地独立开来，非耦合功能拆分展示。</p>
</li>
<li>
<p>因为每次StatefulWidget的变更都会影响到其下的所有子节点，如果只是有限的几个控件变更，可以将这几个控件单独封装为一个StatefulWidget，单独刷新这个Widget，避免其他控件更新影响效率。这个算是最小封装原则，如下图所示，WidgetA这个控件需要更新，则将其单独封装一个StatefulWidget：</p>
</li>
</ul>
<img src="../flutter/widget优化示意图1.png">
<ul>
<li>
<p>Widget的构造方法以及build方法会经常调用，避免在其中执行太多操作，可以转移的操作放在其它地方执行</p>
</li>
<li>
<p>可以尝试将部分Widget实例保持不变，比如增加const修饰，或者StreamBuilder方式指定对象等等，但是这样操作需要当心，有可能会引入问题。</p>
</li>
<li>
<p>如果是自定义控件，采用<code>CustomMultiChildLayout</code>等方式自定义布局展示，可以考虑下使用relayoutBoundary方式，减少节点布局设置</p>
</li>
<li>
<p>绘制时，一些可能会占用较多资源的控件build操作，可以加到<code>RepaintBoundry</code>控件中，比如静态图片，比较复杂的图片设置为一个单独的layer，避免重复build，在GPU中也会存在缓存，减少开销。</p>
</li>
<li>
<p>不可见的控件，尽量不进行build操作</p>
</li>
<li>
<p>自定义控件，避免在绘制时进行创建对象操作，尽可能复用配置，这个和Android是一样的。</p>
</li>
<li>
<p>尽量减少saveLayer操作，如果是透明效果或者裁剪效果，尽量设置到子控件上。</p>
</li>
</ul>
<p>除了与界面渲染相关的优化建议，实际上还有一切其它的性能优化项，比如：</p>
<ul>
<li>部分内容考虑延迟加载</li>
<li>较为耗时的计算操作放置到新的isolate中执行（isolate、Runner与event loop中异步处理的会单独说明，这些还是有很大区别的）</li>
<li>内存加载以及内存泄漏等进行优化</li>
</ul>
<h2 id="flutter生命周期">Flutter生命周期</h2>
<h3 id="state生命周期">State生命周期</h3>
<p>现在使用最多的就是StatefulWidget，先说下State的生命周期。查看State的方法，有这几个需要关注的（按照源码中查找的顺序）：initState、didUpdateWidget、reassemble、setState、deactivate、dispose、build、didChangeDependencies。</p>
<p>其中reassemble是为了开发调试使用的，hot reload时调用该方法，Release版本下该方法不会被调用到，因此通常情况下无需重载该方法。setState与build方法之前已经说明过，不需要再次说明。</p>
<p>其余的几种方法的生命周期如下图：</p>
<img src="../flutter/state生命周期.png">
<p>这张图是网上找的，内容比较全面，不过关于deactivate部分还需要再调整下，下面具体来说每一个方法：</p>
<ul>
<li>
<p>构造方法不用详细说明，创建State实例后才会执行各种操作。</p>
</li>
<li>
<p>initState 这个方法只在 <code>void _firstBuild()</code>中调用到，而_firstBuild方法只会在Element的<code>mount</code>方法中调用到，因此<code>initState</code>只会在这个控件第一次创建时才会触发。</p>
</li>
<li>
<p>didChangeDependencies 这个方法有很多触发地方，首次同样也是在_firstBuild方法中，在initState方法执行后触发。除此以外，还会在<code>notifyDependent</code>方法中触发，而notifyDependent方法在<code>void notifyClients(InheritedWidget oldWidget)</code>方法中调用到，最后的方法是InheritedWidget参数变更时的触发方法（InheritedWidget的具体原理以及常用方式在以后会详细说明）。<br>所以总结一下，didChangeDependencies有两种执行时机：1、会在initState之后执行；2、会在依赖的InheritedWidget发生变化的时执行</p>
</li>
<li>
<p>didUpdateWidget 这个方法会在<code>StatefulElement.update(StatefulWidget newWidget)</code>中执行，而后面一个方法我们很熟悉了，就是之前判断Widget变更的四种条件之一了，再看下源码：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">	  updateSlotForChild(child, newSlot);</span><br><span class="line">	child.update(newWidget);</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以didUpdateWidget的执行时机在于Widget实例变更了，但是Element实例没有变更的情况，也就是runtimeType与Key一致的情况。</p>
<ul>
<li>
<p>deactivate 调用时机同样在widget变更的四种条件之一，节点树构建时，发现某个节点不存在了，将其设置状态为deactvate。实际上deactivate调用后并不一定会直接调用dispose方法，framework在某些情况下会将remove掉的子树重新设置到其他位置，这时候会调用deactivate以及build方法，但不会调用dispose方法。例如路由设置，A界面跳转到B界面，这时A界面就会触发deactivate以及build方法。同样的如果从B界面返回到A界面，framework需要重新将子树放回放回原来的位置，同样会触发A界面的deactivate以及build方法。</p>
</li>
<li>
<p>dispose 这个方法就很明确了，当Element销毁时调用该方法，调用时机在<code>unmount</code>中。</p>
</li>
</ul>
<h3 id="app生命周期">App生命周期</h3>
<p>App生命周期监听可以通过<code>WidgetsBindingObserver</code>类进行设置，里面存在一个<code>void didChangeAppLifecycleState(AppLifecycleState state)</code>方法，实际使用时可以通过mixin方式进行监听。例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.inactive:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'inactive state.'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.resumed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'resumed state.'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.paused:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'paused state.'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.suspending:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'suspending state.'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'unknown state.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四种状态分别进行说明：</p>
<ul>
<li>resumed 与Android类似，表示界面可见，可响应事件</li>
<li>inactive 表示无法获取焦点，无法响应用户事件，但是会有drawFrame回调，比如弹出dialog情况</li>
<li>paused 应用挂起，这种情况下drawFrame回调也不会有，比如退到后台</li>
<li>suspending ios中没有该状态，pause之后的状态，应用停止。该状态不常用</li>
</ul>
<p>常见的状态切换：</p>
<p>应用退到后台：inactive -&gt; paused <br><br>
应用后台转到前台： inactive -&gt; resumed</p>
<h3 id="widget-element-与-renderobject生命周期">Widget、Element 与 RenderObject生命周期</h3>
<p>之前的源码分析中已经做了详细的说明，有空的时候画一张图补上吧，下面是找的一张网上图片：</p>
<img src="../flutter/element生命周期.png">

      
    </div>

    

    
    
    

    

    
      
    
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>oldsun</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://xinbaos.github.io/Flutter渲染原理与性能优化/" title="Flutter渲染原理与性能优化">http://xinbaos.github.io/Flutter渲染原理与性能优化/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flutter/" rel="tag"># Flutter</a>
          
            <a href="/tags/dart/" rel="tag"># dart</a>
          
            <a href="/tags/性能/" rel="tag"># 性能</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Flutter 常用布局-多元素布局3/" rel="next" title="Flutter 常用布局-多元素布局3">
                <i class="fa fa-chevron-left"></i> Flutter 常用布局-多元素布局3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Flutter测试脚本/" rel="prev" title="Flutter测试脚本开发">
                Flutter测试脚本开发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.gif" alt="oldsun">
            
              <p class="site-author-name" itemprop="name">oldsun</p>
              <div class="site-description motion-element" itemprop="description">修身，齐家，治国，平天下</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#flutter示例说明"><span class="nav-number">1.</span> <span class="nav-text">Flutter示例说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#widge类型说明"><span class="nav-number">2.</span> <span class="nav-text">Widge类型说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#界面构建过程"><span class="nav-number">3.</span> <span class="nav-text">界面构建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#widget-element和renderobject三者关系"><span class="nav-number">3.1.</span> <span class="nav-text">Widget、Element和RenderObject三者关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flutter与android界面开发对比"><span class="nav-number">3.2.</span> <span class="nav-text">Flutter与Android界面开发对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#界面创建过程"><span class="nav-number">3.3.</span> <span class="nav-text">界面创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#界面刷新过程"><span class="nav-number">3.4.</span> <span class="nav-text">界面刷新过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#界面渲染过程"><span class="nav-number">4.</span> <span class="nav-text">界面渲染过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#约束条件"><span class="nav-number">4.1.</span> <span class="nav-text">约束条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继续渲染过程分析"><span class="nav-number">4.2.</span> <span class="nav-text">继续渲染过程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能优化"><span class="nav-number">5.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flutter生命周期"><span class="nav-number">6.</span> <span class="nav-text">Flutter生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#state生命周期"><span class="nav-number">6.1.</span> <span class="nav-text">State生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#app生命周期"><span class="nav-number">6.2.</span> <span class="nav-text">App生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#widget-element-与-renderobject生命周期"><span class="nav-number">6.3.</span> <span class="nav-text">Widget、Element 与 RenderObject生命周期</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oldsun</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">74k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">1:07</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
